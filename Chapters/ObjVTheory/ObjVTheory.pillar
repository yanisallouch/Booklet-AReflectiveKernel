! ! Un noyau minimal réflexif basé sur les classes

''La différence entre les classes et les objets a été soulignée à plusieurs reprises. Dans la vision présentée ici, ces concepts appartiennent à des mondes différents : le texte du programme ne contient que des classes ; à l'exécution, seuls les objets existent. Cette approche n'est pas la seule. L'une des sous-cultures de la programmation orientée objet, influencée par Lisp et illustrée par Smalltalk, considère les classes comme des objets eux-mêmes, qui ont toujours une existence au moment de l'exécution.'' - B. Meyer, Object-Oriented Software Construction

Comme l'exprime cette citation, il existe un domaine où les classes sont de véritables objets, des instances d'autres classes. Dans de tels systèmes tels que Smalltalk, Pharo, CLOS, les classes sont décrites par d'autres classes et forment des architectures souvent réflexives, chacune décrivant le niveau précédent. Dans ce chapitre, nous allons explorer un noyau minimal réflectif basé sur les classes, inspiré de ObjVlisp ${cite:ref=Coin87a}$. Dans le chapitre suivant, vous implémenterez pas à pas un tel noyau avec moins de 30 méthodes.

!!! L'inspiration d'ObjVlisp

ObjVlisp a été publié pour la première fois en 1986 alors que les fondements de la programmation orientée objet étaient encore en train d'émerger ${cite:ref=Coin87a}$. ObjVlisp possède des métaclasses explicites et supporte la réutilisation des métaclasses. Il a été inspiré du noyau de Smalltalk-78. Le noyau SOM-DSOM d'IBM est similaire à ObjVLisp tout en étant implémenté en C\+\+ ${cite:ref=Danf94b}$. ObjVlisp est un sous-ensemble du noyau réflectif de CLOS (Common Lisp Object System) puisque CLOS réifie les variables d'instance, les fonctions génériques et la combinaison de méthodes ${cite:ref=Stee90a}$ ${cite:ref=Kicz91a}$. En comparaison avec ObjVlisp, Smalltalk et Pharo ont des métaclasses implicites et aucune réutilisation de métaclasses sauf par héritage de base ${cite:ref=Blac09a}$. Cependant, ils sont plus stables comme l'expliquent Bouraqadi et al ${cite:ref=Grau89a}$ ${cite:ref=Bour98a}$.

L'étude de ce noyau en vaut vraiment la peine, car il possède les propriétés suivantes :
- Il unifie les classes et les instances (il n'y a qu'une seule structure de données pour représenter tous les objets, classes comprises),
- Il est composé de seulement deux classes ==Class== et ==Object== (il s'appuie sur des éléments existants tels que les booléens, les tableaux et les chaînes de caractères du langage d'implémentation sous-jacent),
- Elle soulève la question de la régression infinie de la méta-circularité (une classe est une instance d'une autre classe qui est une instance d'une autre classe encore, etc.) et de la manière de la résoudre,
- Elle nécessite de prendre en compte l'allocation, l'initialisation des classes et des objets, le passage des messages ainsi que le processus de bootstrap,
- Il peut être implémenté en moins de 30 méthodes dans Pharo.

N'oubliez pas que ce noyau est auto-décrit. Nous allons commencer à expliquer certains aspects, mais comme tout est lié, vous devrez peut-être lire le chapitre deux fois pour bien comprendre.

!!! Les six postulats d'ObjVLisp

Le noyau original d'ObjVlisp est défini par six postulats ${cite:ref=Coin87a}$. Certains d'entre eux semblent un peu dépassés par les normes modernes, et le 6ème postulat est tout simplement faux comme nous l'expliquerons plus tard (une solution est simple à concevoir et à mettre en œuvre).

Voici les six postulats tels qu'ils sont énoncés dans l'article, par souci de perspective historique.

# Un objet représente un élément de connaissance et un ensemble de capacités.
# Le seul protocole pour activer un objet est le passage de messages : un message spécifie la procédure à appliquer (dénotée par son nom, le sélecteur) et ses arguments.
# Chaque objet appartient à une classe qui spécifie ses données (attributs appelés champs) et son comportement (procédures appelées méthodes). Les objets seront générés dynamiquement à partir de ce modèle; ils sont appelés instances de la classe. Suivant Platon, toutes les instances d'une classe ont la même structure et la même forme, mais diffèrent par les valeurs de leurs variables d'instance communes.
# Une classe est aussi un objet, instancié par une autre classe, appelée sa métaclasse. En conséquence (P3), à chaque classe est associée une métaclasse qui décrit son comportement en tant qu'objet. La métaclasse primitive initiale est la classe Class, construite comme sa propre instance.
# Une classe peut être définie comme une sous-classe d'une (ou plusieurs) autre(s) classe(s). Ce mécanisme de sous-classement permet le partage des variables d'instance et des méthodes, et s'appelle l'héritage. La classe Object représente le comportement le plus commun partagé par tous les objets.
# Si les variables d'instance possédées par un objet définissent un environnement local, il existe également des variables de classe définissant un environnement global partagé par toutes les instances d'une même classe. Ces variables de classe sont définies au niveau de la métaclasse selon l'équation suivante : variable de classe [un-objet] = variable d'instance [classe d'un-objet].


!!! Aperçu du noyau

Si vous ne saisissez pas entièrement l'aperçu suivant, ne vous inquiétez pas. Ce chapitre complet est là pour s'assurer que vous le comprendrez.
Commençons.

Contrairement à un véritable noyau de langage uniforme, ObjVlisp ne considère pas les tableaux, les booléens, les chaînes de caractères, les nombres ou tout autre objet élémentaire comme faisant partie du noyau, comme c'est le cas dans un véritable bootstrap tel que celui de Pharo. Le noyau d'ObjVLisp se concentre sur la compréhension des relations fondamentales Classe/Objet.

La figure *@fig:ObjVlisp* montre les deux classes centrales du noyau :
- ==Object== qui est la racine du graphe d'héritage et est une instance de ==Class==.
- ==Class== est la première classe et la racine de l'arbre d'instanciation et l'instance d'elle-même comme nous le verrons plus tard.

+Le noyau ObjVlisp : un noyau minimal basé sur les classes.>file://figures/ObjVlispMore.pdf|width=60|label=fig:ObjVlisp+


La figure *@withSing* montre que la classe ==Workstation== est une instance de la classe ==Class== puisque c'est une classe et qu'elle hérite de ==Object== le comportement par défaut que les objets doivent présenter. La classe ==WithSingleton== est une instance de la classe ==Class== mais en plus elle hérite de ==Class==, puisque c'est une métaclasse : ses instances sont des classes. En tant que telle, elle modifie le comportement des classes. La classe ==SpecialWorkstation== est une instance de la classe ==WithSingleton== et hérite de ==Workstation==, puisque ses instances présentent le même comportement que ==Workstation==.

 +Le noyau avec des métaclasses spécialisées.>file://figures/ObjVlispSingleton.pdf|width=70|label=withSing+

Les deux diagrammes *@fig:ObjVlisp* et *@withSing* seront expliqués pas à pas tout au long de ce chapitre.

@@note Le point clé de la compréhension d'une telle architecture réflexive est que le passage de messages cherche toujours des méthodes dans la classe du receveur du message et suit ensuite la chaîne d'héritage (Voir Figure *@fig:kernel2*).

+Comprendre les métaclasses à l'aide du passage de messages.>file://figures/ObjVlispSingleton2.pdf|width=90|label=fig:kernel2+

La figure *@fig:kernel2* illustre deux cas principaux :
- Lorsque nous envoyons un message à ==BigMac== ou ==Minna==, la méthode correspondante est recherchée dans leurs classes correspondantes ==Workstation== ou ==SpecialWorkstation== et suit le lien d'héritage jusqu'à ==Object==.
- Lorsque nous envoyons un message aux classes ==Workstation== ou ==SpecialWorkstation==, la méthode correspondante est recherchée dans leur classe, la classe ==Class== et jusqu'à ==Object==.

!!! Instances

Dans ce noyau, il n'existe qu'un seul lien d'instanciation ; il est appliqué à tous les niveaux comme le montre la figure *@fig:Instantiation*:
%+Simple instances.>file://figures/Ref-Instances.png|width=50|label=fig:Instances+
- Les instances de terminaux sont évidemment des objets : une station de travail nommée ==mac1== est une instance de la classe ==Workstation==, un point ==10@20== est une instance de la classe ==Point==.
- Les classes sont aussi des objets (instances) d'autres classes : la classe ==Workstation== est une instance de la classe ==Class==, la classe ==Point== est une instance de la classe ==Class==.

+Chaîne d'instanciation : les classes sont aussi des objets.>file://figures/Ref-InstantiationLink.pdf|width=72|label=fig:Instantiation+

Dans nos diagrammes, nous représentons les objets (principalement les instances terminales) sous forme de rectangles arrondis avec la liste des valeurs des variables d'instance.
Comme les classes sont des objets, ''lorsque nous voulons souligner que les classes sont des objets'', nous utilisons la même convention graphique que celle de la figure *@fig:PointClassAsObject*.





!!!! Gestion de la récursion infinie

Une classe est un objet. Elle est donc une instance d'une autre classe, sa métaclasse. Cette métaclasse est aussi un objet, une instance d'une métamétaclasse qui est aussi un objet, une instance d'une autre métamétaclasse, etc. Pour arrêter cette potentielle récursion infinie, ObjVlisp est similaire aux solutions proposées dans de nombreux systèmes de métaclasses : une instance (par exemple, ==Class==) est une instance d'elle-même.

Dans ObjVLisp :
- ==Class== est la classe initiale et la métaclasse,
- ==Class== est une instance d'elle-même, et, directement ou indirectement, toutes les autres métaclasses sont des instances de ==Class==.

Nous verrons plus tard l'implication de cette auto-instantation au niveau de la structure de la classe elle-même.

!!! Comprendre les métaclasses

Le modèle unifie les classes et les instances. Il découle des postulats du noyau relatifs aux instances que :
- Tout objet est une instance d'une classe,
- Une classe est un objet instance d'une métaclasse, et
- Une métaclasse est seulement une classe qui génère des classes.

Au niveau de l'implémentation, il n'existe qu'un seul type d'entité : les objets. Il n'y a pas de traitement spécial pour les classes. Les classes sont instanciées selon le même processus que les instances terminales. On leur envoie des messages de la même manière qu'aux autres objets.

Cette unification entre instances et classes ne signifie pas que les objets et les classes ont la même distinction.
En effet, tous les objets ne sont pas des classes. En particulier, la seule différence entre une classe et une instance est la capacité de répondre au message de création : ==new==. Seule une classe sait y répondre. Ainsi, les métaclasses ne sont que des classes dont les instances sont des classes comme le montre la figure *@fig:InstantiationPap*.

+Tout est un objet. Les classes sont juste des objets qui peuvent créer d'autres objets, et les métaclasses sont juste des classes dont les instances sont des classes.>file://figures/instancePatatoid.pdf|width=45|label=fig:InstantiationPap+


!!! Structure de l'instance

Le modèle n'apporte pas vraiment de nouveauté concernant la structure des instances par rapport à des langages tels que Pharo ou Java.

Les variables d'instance sont une séquence ordonnée de variables d'instance définies par une classe. Ces
variables d'instance sont partagées par toutes les instances.
Les valeurs de ces variables d'instance sont spécifiques à chaque instance.
La figure *@fig:Ref-Instances* montre que les instances de ==Workstation== ont deux valeurs : un nom et un nœud suivant.


+Les instances de ==Workstation== ont deux valeurs : leur nom et leur prochain noeud.>file://figures/Ref-Instances.pdf|width=60|label=fig:Ref-Instances+

De plus, nous remarquons qu'un objet possède un pointeur vers sa classe. Comme nous le verrons plus tard lorsque nous aborderons l'héritage, chaque objet possède une variable d'instance class (héritée de ==Object==) qui pointe vers sa classe.


Notez que cette gestion d'une variable d'instance de classe définie dans ==Object== est spécifique au modèle.
Dans Pharo par exemple, l'identification de la classe n'est pas gérée comme une variable d'instance déclarée, mais comme un élément faisant partie de tout objet. Il s'agit d'un index dans une table de classe.

!!! A propos du comportement

Poursuivons avec le comportement de base des instances. Comme dans les langages modernes basés sur les classes, ce noyau doit représenter la manière dont les méthodes sont stockées et recherchées.

Les méthodes appartiennent à une classe. Elles définissent le comportement de toutes les instances de la classe.
Elles sont stockées dans un dictionnaire de méthodes qui associe une clé (le sélecteur de méthode) et le corps de la méthode.

Puisque les méthodes sont stockées dans une classe, le dictionnaire de méthodes doit être décrit dans la métaclasse. Ainsi, le dictionnaire de méthodes d'une classe est la ''valeur'' de la variable d'instance ==methodDict== définie sur la métaclasse ==Class==. Chaque classe aura son propre dictionnaire de méthodes.

!!! La classe en tant qu'objet

Voici les informations minimales qu'une classe devrait avoir :
- Une liste de variables d'instance pour décrire les valeurs que les instances vont contenir,
- Un dictionnaire de méthodes pour contenir les méthodes,
- Une superclasse pour rechercher les méthodes héritées.

Cet état minimal est similaire à celui de Pharo : la classe Pharo ==Behavior== possède un format (description compacte des variables d'instance), un dictionnaire de méthodes et un lien vers une superclasse.

Dans ObjVLisp, nous avons un nom pour identifier la classe. En tant que fabrique d'instance, la métaclasse Class possède quatre variables d'instance qui décrivent une classe :
- name, le nom de la classe,
- superclass, sa superclasse (nous nous limitons à l'héritage simple),
- i-v, la liste de ses variables d'instance, et
- methodDict, un dictionnaire de méthodes.

Puisqu'une classe est un objet, une classe possède la variable d'instance ==class== héritée de ==Object== qui fait référence à sa classe comme à n'importe quel objet.

+La classe ==Point== en tant qu'objet.>file://figures/Ref-PointClassAsObject.pdf|width=70|label=fig:PointClassAsObject+

!!!! Exemple : classe Point

La figure *@fig:PointClassAsObject* montre les valeurs des variables d'instance de la classe ==Point== telle qu'elle est déclarée par le programmeur et avant que l'initialisation de la classe et l'héritage n'aient lieu.
- C'est une instance de la classe ==Class== : il s'agit en effet d'une classe.
- Elle est nommée =='Point'==.
- Il hérite de la classe ==Object==.
- Elle possède deux variables d'instance : ==x== et ==y== : après l'héritage, il y aura trois variables d'instance : ==class==, ==x==, et ==y==.
- Il possède un dictionnaire de méthodes.


+==Class== en tant qu'objet.>file://figures/Ref-ClassClassAsObject.pdf|width=70|label=fig:ClassClassAsObject+

!!!! Exemple : classe Class

La figure *@fig:ClassClassAsObject* décrit la classe ==Class== elle-même. En effet, elle est aussi un objet.
- C'est une instance de la classe ==Class== : en effet c'est une classe.
- Elle est nommée =='Class'==.
- Elle hérite de la classe ==Object==.
- Elle possède quatre variables d'instance définies localement : ==name==, ==superclass==, ==i-v==, et ==methodDict==.
- Il possède un dictionnaire de méthodes.

+A travers le prisme des objets.>file://figures/Ref-InstanceGlobalPicture.pdf|width=70|label=fig:Instanceshier+

!!!! Tout est un objet

La figure *@fig:Instanceshier* décrit une situation typique d'instances terminales, de classes et de métaclasses lorsqu'elle est vue du point de vue des objets.
Nous voyons trois niveaux d'instances : les objets terminaux (==mac1== et ==mac2== qui sont des instances de ==Workstation==), les objets de classe (==Workstation== et ==Point== qui sont des instances de ==Class==) et la métaclasse (==Class== qui est une instance d'elle-même).

+L'envoi d'un message est un processus en deux étapes : la recherche de la méthode et l'exécution.>file://figures/InheritanceDiagram-sendingMessage.pdf|width=45|label=fig:ToSteps+


!!! Envoi d'un message
@sec_message

Dans ce noyau, le deuxième postulat stipule que la seule façon d'effectuer des calculs est de passer des messages.

L'envoi d'un message est un processus en deux étapes, comme l'illustre la figure*@fig:ToSteps*.
# Recherche de la méthode : la méthode correspondant au sélecteur est recherchée dans la classe du receveur et ses superclasses.
# Exécution de la méthode : la méthode est appliquée au receveur. Cela signifie que ==self== ou ==this== dans la méthode sera lié au receveur.

Conceptuellement, l'envoi d'un message peut être décrit par la composition de fonctions suivante :

[[[
sending a message (receiver argument)
	 return apply (lookup (selector classof(receiver) receiver) receiver arguments)
]]]


!!!! Méthode lookup
Le processus de recherche est maintenant défini conceptuellement comme suit :
# La recherche commence dans la ""classe"" du ""receveur"".
# Si la méthode est définie dans cette classe (c'est-à-dire si la méthode est définie dans le dictionnaire des méthodes), elle est retournée.
# Sinon, la recherche continue dans la superclasse de la classe actuellement explorée.
# Si aucune méthode n'est trouvée et qu'il n'y a pas de superclasse à explorer (si nous sommes dans la classe ==Object==), il s'agit d'une erreur (c'est-à-dire que la méthode n'est pas définie).

+La recherche d'une méthode est un processus en deux étapes : il faut d'abord aller dans la classe du receveur puis suivre l'héritage.>file://figures/Ref-LookupNoError.pdf|width=55|label=fig:LookupNoError+

La méthode lookup parcourt le graphe d'héritage une classe à la fois en utilisant le lien superclasse. Voici une description possible de l'algorithme de recherche qui sera utilisé pour les méthodes d'instance et de classe.

[[[
lookup (selector class receiver):
   if the method is found in class
      then return it
      else if class == Object
           then send the message error to the receiver
           else lookup (selector superclass(class) receiver)
]]]

+Lorsqu'un message n'est pas trouvé, un autre message est envoyé au receveur pour soutenir l'opération de réflexion.>file://figures/Ref-LookupWithError.pdf|width=70|label=fig:LookupWithError+



!!!! Gestion des erreurs

Lorsque la méthode n'est pas trouvée, le message ==error== est envoyé comme indiqué dans la figure *@fig:LookupWithError*. L'envoi d'un message au lieu de simplement signaler une erreur à l'aide d'une trace ou d'une exception est une décision de conception essentielle. Dans Pharo, cela se fait par le biais du message ==doesNotUnderstand:==, et c'est un crochet de réflexion important. En effet, les classes peuvent définir leur propre implémentation de la méthode ==error== et effectuer des actions spécifiques au cas des messages qui ne sont pas compris.  Par exemple, il est possible d'implémenter des proxies (objets représentant d'autres objets distants) ou de compiler du code à la volée en redéfinissant localement un tel message.

Il faut maintenant noter que l'algorithme précédent présente une limitation lorsqu'une méthode manquante possède un nombre arbitraire d'arguments. Ils ne sont pas transmis au message ==error==. Une meilleure façon de gérer cela est de décomposer l'algorithme différemment comme suit :

[[[
lookup (selector class):
   if the method is found in class
      then return it
      else if class == Object
           then return nil
           else lookup (selector superclass(class))
]]]

Et puis nous avons redéfini l'envoi d'un message comme suit :

[[[
sending a message (receiver argument)
   methodOrNil = lookup (selector classof(receiver)).
   if methodOrNil is nil
      then return send the message error to the receiver
      else return apply(methodOrNil receiver arguments)
]]]

!!!! Remarques
Cette recherche est conceptuellement la même que dans Pharo où toutes les méthodes sont publiques et virtuelles. Il n'y a pas de méthodes liées statiquement ; même les méthodes des classes sont recherchées dynamiquement. Cela permet de définir des mécanismes d'enregistrement très élégants et dynamiques.

Bien que la recherche se fasse au moment de l'exécution, elle est souvent mise en cache. Les langages ont généralement plusieurs systèmes de cache, par exemple, global (classe, sélecteur), un par site d'appel, etc.

!!! Héritage

Dans ce noyau, il y a deux aspects de l'héritage à considérer :

- Un statique pour le cas où les sous-classes obtiennent l'état de la super-classe. Cet héritage de variable d'instance est statique dans le sens où il ne se produit qu'une seule fois au moment de la création de la classe, c'est-à-dire au moment de la compilation.

- Un dynamique pour le comportement où les méthodes sont recherchées pendant l'exécution du programme. Dans ce cas, l'arbre d'héritage est parcouru au moment de l'exécution.

Examinons ces deux aspects.

!!!! Héritage des variables d'instance
L'héritage des variables d'instance se fait au moment de la création de la classe. De ce point de vue, il est statique et réalisé une seule fois.
Lorsqu'une classe ==C== est créée, ses variables d'instance sont l'union des variables d'instance de sa superclasse
et des variables d'instance définies localement dans la classe ==C==.
Chaque langage définit la sémantique exacte de l'héritage des variables d'instance, par exemple, s'il accepte ou non les variables d'instance portant le même nom. Dans notre modèle, nous décidons d'utiliser la méthode la plus simple : il ne doit pas y avoir de noms en double.

[[[
instance-variables(aClass) =
	union (instance-variables(superclass(aClass)), local-instance-variables(aClass))
]]]

Un mot sur l'union : lorsque l'implémentation du langage est basée sur des décalages pour accéder aux variables d'instance, l'union doit s'assurer que l'emplacement des variables d'instance héritées reste ordonné par rapport à la superclasse. En général, nous voulons pouvoir appliquer les méthodes de la superclasse aux sous-classes sans les recopier et les recompiler. En effet, si une méthode utilise une variable à une position donnée dans les listes de variables d'instance, l'application de cette méthode aux instances des sous-classes devrait fonctionner.
Dans l'implémentation proposée au chapitre suivant, nous utiliserons des accesseurs et ne supporterons pas l'accès direct aux variables d'instance depuis le corps d'une méthode.

!!!! Recherche de méthode
Comme décrit précédemment dans la section *@sec_message*, les méthodes sont recherchées au moment de l'exécution.
Les méthodes définies dans les superclasses sont réutilisées et appliquées aux instances des sous-classes.
Contrairement à l'héritage des variables d'instance, cette partie de l'héritage est dynamique, c'est-à-dire qu'elle se produit pendant l'exécution du programme.


!!! Objet : définition du comportement minimal de tout objet

==Object== représente le comportement minimal que tout objet devrait comprendre, par exemple, renvoyer la classe de l'objet, être capable de gérer les erreurs et initialiser l'objet.
C'est pourquoi ==Object== est la racine de la hiérarchie. Selon le langage, ==Object== peut être complexe. Dans notre noyau, elle reste minimale comme nous le montrerons dans le chapitre sur l'implémentation.

La figure *@fig:inheritancegraph* montre le graphe d'héritage sans la présence d'instanciation.
Une station de travail est un objet (c'est-à-dire qu'elle doit au moins comprendre le comportement minimal), donc la classe ==Workstation== hérite directement ou indirectement de la classe ==Object==.
Une classe est également un objet (c'est-à-dire qu'elle doit comprendre le comportement minimal), la classe ==Class== hérite donc de la classe ==Object==. En particulier, la variable d'instance ==class== (notez la minuscule) est héritée de la classe ==Object==.


+Graphique d'héritage complet : Chaque classe hérite finalement de la classe ==Object==.>file://figures/Ref-InheritanceGraph.pdf|width=45|label=fig:inheritancegraph+



!!!! Remarque.
Dans Pharo, la classe ==Object== n'est pas la racine de l'héritage. La racine est en fait ==ProtoObject==, et ==Object== en hérite. La plupart des classes héritent toujours de ==Object==. L'objectif de conception de ==ProtoObject== est particulier : générer le plus d'erreurs possible. Ces erreurs peuvent ensuite être capturées via la redéfinition de ==doesNotUnderstand:==
et peuvent supporter différents scénarios tels que l'implémentation d'un proxy.

!!! Héritage et instanciation ensemble

Maintenant que nous avons vu les graphes d'instanciation et d'héritage, nous pouvons examiner l'image complète.
La figure *@fig:kernel22* montre les graphes et en particulier comment ces graphes sont utilisés pendant la résolution des messages :
- le lien d'instanciation est utilisé pour trouver la classe de départ afin de rechercher toutes les méthodes associées au message reçu.
- le lien d'héritage est utilisé pour trouver les méthodes héritées.

Ce processus est le même lorsque nous envoyons des messages aux classes elles-mêmes. Il n'y a pas de différence entre envoyer un message à un objet ou à une classe. Le système effectue ''toujours'' les mêmes étapes.

+Noyau avec lien d'instanciation et d'héritage.>file://figures/Ref-KernelTwo.pdf|width=60|label=fig:kernel22+



!!! Révision de la sémantique du self et du super

Comme notre expérience nous a montré que même certains auteurs de livres se trompent sur la sémantique essentielle de la programmation orientée objet, nous passons en revue ici quelques faits que les programmeurs familiers de la programmation orientée objet devraient maîtriser. Pour plus d'informations, reportez-vous à ''Pharo Par l'Exemple'' ou au Pharo Mooc disponible sur *http://mooc.pharo.org*.

Comme expliqué dans la section *@sec_message*, l'envoi d'un message à un objet déclenche toujours la recherche de la méthode correspondante dans la classe du receveur.

Il faut maintenant distinguer deux cas : ==self== et ==super==.
Dans le corps d'une méthode, tant ""self"" (également appelé ""this"" dans des langages comme Java) que ""super"" représentent toujours le receveur du message. Oui, vous avez bien lu, les deux ""self"" et ""super"" représentent toujours le receveur !

La différence réside dans la classe à partir de laquelle la recherche commence :

- Pour ""self"". Lorsqu'un message est envoyé à ==self==, la recherche de la méthode à exécuter commence dans la classe du receveur.

Lorsqu'un message est envoyé à ==super==, la recherche commence dans la superclasse de la classe de la méthode.

- Pour ""super"". Lorsqu'un message est envoyé à ==super==, la recherche de la méthode commence dans la superclasse de la classe contenant l'expression super.

Cette distinction entre ""self"" et ""super"" est nécessaire pour gérer le cas où une méthode est redéfinie localement dans une classe mais que vous devez invoquer le comportement défini dans ses superclasses. Notez que la méthode de la superclasse peut être définie non pas dans une superclasse directe mais dans une classe ancêtre, il est donc nécessaire d'effectuer une recherche de méthode et cette recherche de méthode doit commencer au-dessus de la méthode redéfinie (ici la méthode contenant l'expression ""super""). D'où le nom ""super"".

Notez que la recherche d'une méthode dans le cas de ==super== ne cherche pas dans la superclasse de la classe du receveur, car cela signifierait qu'elle pourrait tourner en boucle à l'infini dans le cas d'un arbre d'héritage avec trois classes.


En regardant la figure *@fig:LookupWithSelfInSuperclassMethod*, nous voyons que le point clé est que ==B new bar== renvoie 50 puisque
la méthode est recherchée dynamiquement et self représente le receveur, c'est-à-dire l'instance de la classe ==B==. Ce qu'il est important de voir, c'est que les envois de ==self== agissent comme un crochet et que le code des sous-classes peut être injecté dans le code de la superclasse.

[[[
A new foo
>>> 10
B new foo
>>> 50
A new bar
>>> 10
B new bar
>>> 50
]]]

+self représente toujours le receveur.file://figures/LookupWithSelfInSuperclassMethod.pdf|width=40|label=fig:LookupWithSelfInSuperclassMethod+

+Le diagramme séquentiel de self représente toujours le receveur.>file://figures/SelfLookupSequenceDiagram.pdf|width=60|label=fig:SelfLookupSequenceDiagram+


Pour ==super==, la situation décrite dans la figure *@fig:LookupWithSuperInSuperclassMethodThreeClasses* montre que ==super== représente le receveur, mais que lorsque ==super== est le receveur d'un message, la méthode est recherchée différemment (en partant de la superclasse de la classe utilisant super) ; ainsi ==R new bar== renvoie 100, mais ni 20 ni 60.

+super représente le receveur, mais la recherche de la méthode commence dans la superclasse de la classe de la méthode utilisant super. >file://figures/LookupWithSuperInSuperclassMethodThreeClasses2.pdf|width=40|label=fig:LookupWithSuperInSuperclassMethodThreeClasses+

[[[
Q new bar
>>> 20
R new bar
>>> 100
]]]

En conclusion, nous pouvons dire que ==self== est dynamique et ==super== statique. Expliquons ce point de vue :
- Lorsqu'on envoie un message à ==self==, la recherche de la méthode commence dans la classe du receveur. ==self== est lié au moment de l'exécution. Nous ne connaissons pas sa valeur avant le moment de l'exécution.
- ==super== est statique dans le sens où, alors que l'objet vers lequel il pointera n'est connu qu'au moment de l'exécution, l'endroit où chercher la méthode est connu au moment de la compilation : il doit commencer à chercher dans la classe au-dessus de celle qui contient super.

!!! Création d'objets
Nous sommes maintenant prêts à comprendre la création d'objets. Dans ce modèle, il n'y a qu'une seule façon de créer des instances : nous devons envoyer le message ==new== à la classe avec une spécification des valeurs des variables d'instance comme argument.

!!! Création d'instances de la classe Point
Les exemples suivants montrent plusieurs instanciations de points. Ce que nous voyons, c'est que le modèle hérite de la tradition Lisp de passer des arguments en utilisant des clés et des valeurs, et que l'ordre des arguments n'est pas important.

[[[
Point new :x 24 :y 6
>>> aPoint (24 6)
Point new :y 6 :x 24
>>> aPoint (24 6)
]]]

Lorsqu'aucune valeur n'est spécifiée, la valeur d'une variable d'instance est initialisée à nil. CLOS fournit la notion de valeurs par défaut pour l'initialisation des variables d'instance. Elle peut être ajoutée à ObjVlisp comme un exercice et n'apporte pas de difficultés conceptuelles.

[[[testcase=true
Point new
>>> aPoint (nil nil)
]]]

Lorsque le même argument est passé plusieurs fois, alors l'implémentation prend la première occurrence.
[[[testcase=true
Point new :y 10 :y 15
>>> aPoint (nil 10)
]]]

Nous ne devrions pas trop nous inquiéter de ces détails : Le point est que nous pouvons passer plusieurs arguments avec une balise pour les identifier.

!!! Création de la classe Point instance de Class
Puisque la classe ==Point== est une instance de la classe ==Class==, pour la créer, nous devons envoyer le message ==new== à la classe comme suit :

[[[testcase=true
Class new
   :name 'Point'
   :super 'Object'
   :ivs #(x y)
>>> aClass
]]]

Ce qui est intéressant à voir ici, c'est que nous utilisons exactement la même méthode pour créer une instance de la classe ==Point== que la classe elle-même.
Notez que la possibilité d'avoir la même façon de créer des objets ou des classes est également due au fait que les arguments sont spécifiés en utilisant une liste de paires.

Une implémentation pourrait avoir deux messages différents pour créer des instances et des classes. Dès lors que les mêmes méthodes ==new==, ==allocate==, ou ==initialize== sont impliquées, l'essence de la création d'objet est similaire et uniforme.

!!!! Création d'instances : Rôle de la métaclasse

Le diagramme suivant (Figure *@fig:metaclassrole*) montre que malgré ce que l'on pourrait croire, lorsque nous créons une instance d'un terminal, la métaclasse ==Class== est impliquée dans le processus. En effet, nous envoyons le message ==new== à la classe, pour résoudre ce message, le système va chercher la méthode dans la classe du receveur (ici ==Workstation==) qui est la métaclasse ==Class==. La méthode ==new== est trouvée dans la métaclasse et appliquée au receveur, la classe ==Workstation==. Son effet est de créer une instance de la classe ==Workstation==.

+Rôle de la métaclasse pendant la création de l'instance : Application de la résolution de messages simples.>file://figures/Ref-InstanceCreationMetaclassRole.pdf|width=65|label=fig:metaclassrole+

La même chose se produit lors de la création d'une classe. La figure *@fig:ClassCreation* montre le processus. Nous envoyons un message, cette fois à la classe ==Class==. Le système ne fait pas d'exception et pour résoudre le message, il cherche la méthode dans la classe du receveur. La classe du receveur est elle-même, donc la méthode ==new== trouvée dans ==Class== est appliquée à ==Class== (le receveur du message), et une nouvelle classe est créée.

+Rôle de la métaclasse pendant la création de la classe : Application de la résolution du message simple - le lien d'auto-instanciation est suivi.>file://figures/Ref-ClassCreation.pdf|width=65|label=fig:ClassCreation+

!!!! new = allouer et initialiser
La création d'une instance est la composition de deux actions : un message d'allocation de mémoire ==allocate== et un message d'initialisation d'objet ==initialize==.

En syntaxe Pharo, cela signifie :
[[[
aClass new: args = (aClass allocate) initialize: args
]]]

Nous devrions voir ce qui suit :
- Le message ==new== est un message envoyé à une classe. La méthode ==new== est une méthode de classe.
- Le message ==allocate== est un message envoyé à une classe. La méthode ==allocate== est une méthode de classe.
- Le message ==initialize:== sera exécuté sur toute instance nouvellement créée. S'il est envoyé à une classe, une méthode de classe ==initialize:== sera impliquée. S'il est envoyé à un objet d'un terminal, une méthode d'instance ==initialize:== sera exécutée (définie dans ==Object==).


!!!! Allocation d'objet : le message allocate
Allouer un objet signifie allouer suffisamment d'espace à l'état de l'objet mais il y a plus : les instances doivent être marquées avec leur nom de classe ou leur id. Il existe un invariant dans ce modèle et en général dans les modèles de programmation orientés objet. Chaque objet doit avoir un identifiant pour sa classe, sinon le système s'arrêtera lorsqu'il essaiera de résoudre un message.

L'allocation d'objet doit retourner une instance nouvellement créée avec :
- des variables d'instance vides (pointant vers nil par exemple) ;
- un identifiant de sa classe.

Dans notre modèle, le marquage d'un objet comme instance d'une classe est effectué en fixant la valeur de la variable d'instance ==class== héritée de ==Object==. Dans Pharo, cette information n'est pas enregistrée comme une variable d'instance mais encodée dans la représentation interne de l'objet dans la machine virtuelle.

La méthode ==allocate== est définie sur la métaclasse ==Class==. Voici quelques exemples d'allocation.

[[[testcase=true
Point allocate
>>> #(Point nil nil)
]]]
Une allocation de point alloue trois slots : un pour la classe et deux pour les valeurs x et y.

[[[testcase=true
Class allocate
>>>#(Class nil nil nil nil nil)
]]]

L'allocation pour un objet représentant une classe alloue six slots : un pour la classe et un pour chacune des variables d'instance de la classe : name, super, iv, keywords, et methodDict.

!!!! Initialisation d'objet
L'initialisation d'un objet est le processus consistant à passer des arguments sous forme de paires clé/valeur et à affecter la ou les valeurs à la ou les variables d'instance correspondantes.

Ce processus est illustré dans l'extrait suivant. Une instance de la classe ==Point== est créée et les paires clé/valeur (:y 6) et (:x 24) sont
spécifiées. L'instance est créée et elle reçoit le message ==initialize:== avec les couples clé/valeur.
La méthode ==initialize:== est chargée de définir les variables correspondantes dans le receveur.

[[[
Point new :y 6  :x 24
>>> #(Point nil nil) initialize: (:y 6 :x 24)]
>>> #(Point 24 6)
]]]

Lorsqu'un objet est initialisé en tant qu'instance d'un terminal, deux actions sont effectuées :
- Premièrement, nous devons obtenir les valeurs spécifiées lors de la création, c'est-à-dire obtenir que la valeur y est 6 et la valeur x est 24,
- Ensuite, nous devons affecter ces valeurs aux variables d'instance correspondantes de l'objet créé.

!!!! Initialisation de la classe
Pendant son initialisation, une classe doit effectuer plusieurs étapes :

- Tout d'abord, comme pour toute initialisation, elle doit obtenir les arguments et les affecter à leurs variables d'instance correspondantes. Ceci est essentiellement mis en œuvre en invoquant la méthode ==initialize== de ==Object== via un appel a super, puisque ==Object== est la superclasse de ==Class==.
- Ensuite, l'héritage des variables d'instance doit être effectué. Avant cette étape, la variable d'instance de la classe ==iv== ne contient que les variables d'instance qui sont définies localement. Après cette étape, la variable d'instance ==iv== contiendra toutes les variables d'instance héritées et locales. En particulier, c'est ici que la variable d'instance ==class== héritée de ==Object== est ajoutée à la liste des variables d'instance de la sous-classe de ==Object==.
- Troisièmement, la classe doit être déclarée comme un pool de classes ou un espace de noms afin que les programmeurs puissent y accéder via son nom.

!!! La classe Class

Nous comprenons maintenant mieux ce qu'est la classe ==Class== :
- C'est la métaclasse initiale et la classe initiale.
- Elle définit le comportement de toutes les métaclasses.
- Elle définit le comportement de toutes les classes.

En particulier, les métaclasses définissent trois messages liés à la création d'instances.
- Le message ==new==, qui crée une instance initialisée de la classe. Il alloue l'instance en utilisant le message de classe ==allocate== puis l'initialise en envoyant le message ==initialize:== à cette instance.
- Le message ==allocate==. Comme le message ==new==, il s'agit d'un message de classe. Il alloue la structure de l'objet nouvellement créé.
- Enfin le message ==initialize:==. Ce message a deux définitions, une sur ==Object== et une sur ==Class==.

Il y a une différence entre la méthode ==initialize:== exécutée lors de toute création d'instance et la méthode ==initialize:== exécutée uniquement lorsque l'instance créée est une classe.

- La première est une méthode définie sur la classe de l'objet et potentiellement héritée de ==Object==. Cette méthode ==initialize:== extrait simplement les valeurs correspondant à chaque variable d'instance de la liste des arguments et les place dans les variables d'instance correspondantes.

- La méthode ==initialize:== de la classe est exécutée lorsqu'une nouvelle instance représentant une classe est exécutée. Le message ==initialize:== est envoyé à l'objet nouvellement créé mais sa spécialisation pour les classes sera trouvée lors de la recherche de méthode et elle sera exécutée. Habituellement, cette méthode invoque les méthodes par défaut, car les paramètres de classe doivent être extraits de la liste d'arguments et placés dans leurs variables d'instance correspondantes. Mais en plus, l'héritage des variables d'instance et la déclaration de la classe dans l'espace de noms de la classe sont effectués.


!!! Définition d'une nouvelle métaclasse
Nous pouvons maintenant étudier comment nous pouvons ajouter de nouvelles métaclasses et voir comment le système les traite.
Créer une nouvelle métaclasse est simple ; il suffit d'hériter d'une métaclasse existante. Peut-être que cela est évident pour vous, mais c'est ce que nous allons vérifier maintenant.

+Métaclasse abstraite : ses instances (c'est-à-dire la classe Node) sont abstraites.>file://figures/Ref-Abstract.pdf|width=60|label=fig:Abstract+

!!!! Abstrait
Imaginons que nous voulions définir des classes abstraites. Nous déclarons qu'une classe est abstraite si elle ne peut pas créer d'instances.
Pour contrôler la création d'instances d'une classe, nous devons définir une nouvelle métaclasse qui l'interdit.
Nous allons donc définir une métaclasse dont les instances (classes abstraites) ne peuvent pas créer d'instances.

Nous créons une nouvelle métaclasse nommée ==AbstractMetaclass== qui hérite de ==Class== et nous redéfinissons la méthode ==new== dans cette métaclasse pour qu'elle lève une erreur (comme le montre la figure *@fig:Abstract*). L'extrait de code suivant définit cette nouvelle métaclasse.

[[[
Class new
	:name 'AbstractMetaclass'
	:super 'Class'
]]]

[[[
AbstractMetaclass
	addMethod: #new
	body: [ :receiver :initargs | receiver error: 'Cannot create instance of class' ]
]]]

Deux faits décrivent les relations entre cette métaclasse et la classe ==Class== :
- ==AbstractMetaclass== est une classe, une instance de ==Class==.
- ==AbstractMetaclass== définit le comportement de la classe : Elle hérite de la ==Class==.

+La métaclasse abstraite au travail.>file://figures/Ref-AbstractLookup.pdf|width=60|label=fig:AbstractLookup+
Nous pouvons maintenant définir une classe abstraite ==Node==.

[[[
AbstractMetaclass new :name 'Node' :super 'Object'
]]]

L'envoi d'un message ==new== à la classe ==Node== soulèvera une erreur.
[[[testcase=true
Node new
>>> Cannot create instance of class
]]]

Une sous-classe de ==Node==, par exemple ==Workstation==, peut être une classe concrète en étant une instance de ==Class== au lieu de ==AbstractMetaclass== mais en héritant toujours de ==Node==. Ce que nous voyons dans la figure *@fig:AbstractLookup* est qu'il y a deux liens, l'instanciation et l'héritage. La recherche de méthode les suit comme nous l'avons présenté précédemment. Elle commence toujours dans la classe du receveur et suit le chemin de l'héritage.

Ce qu'il faut comprendre, c'est que lorsque nous envoyons le message ==new== à la classe ==Workstation==, nous cherchons d'abord les méthodes dans la métaclasse ==Class==. Lorsque nous envoyons le message ==new== à la classe ==Node==, nous cherchons dans sa classe : ==AbstractMetaclass== comme le montre la figure *@fig:AbstractLookup*. En fait, nous faisons ce que nous faisons pour toute instance : nous regardons dans la classe du receveur.


Une méthode de classe est juste implémentée et suit la même sémantique que les méthodes d'instance :
L'envoi du message ==error== à la classe ==Node== commence dans ==AbstractMetaclass==. Comme nous ne l'avons pas redéfini localement et qu'il ne s'y trouve pas, la recherche se poursuit dans la superclasse de ==AbstractClass== : la classe ==Class== puis la superclasse de la classe ==Class==, la classe ==Object==.


!!! À propos de l'état des classes

Imaginons que nous définissions une métaclasse ==WithSingleton== dont les instances sont des classes qui auront une instance unique. La situation est décrite dans la figure *@fig:RefSing*. La classe ==WithSingleton== hérite de ==Class== puisqu'elle veut réutiliser tous les mécanismes de la classe. Elle est également une instance de la classe ==Class==, puisque ==WithSingleton== est une classe et qu'elle peut créer des instances. La classe ==Node== est une instance de la classe ==WithSingleton==. Lorsqu'elle reçoit le message ==new==, la méthode ==new== définie dans la classe ==WithSingleton==
est exécutée. Si la variable d'instance unique est nulle, il invoque le comportement défini dans la classe ==Class==, le stocke dans la variable d'instance unique et le renvoie.

+Une métaclasse WithSingleton : ses instances ne peuvent avoir qu'une seule instance.>file://figures/Ref-Singleton.pdf|width=55|label=fig:RefSing+

Il reste plusieurs questions à poser et auxquelles il faut répondre.

- Quelle est la liste des variables d'instance pour la métaclasse ==WithSingleton== ?
- Où est stockée l'instance unique de la classe ==Node== ou ==Process== ?


!!!! Variable d'instance de WithSingleton

Comme pour toute classe, une sous-classe obtient ses variables d'instance ainsi que les variables d'instance de sa super-classe. Par conséquent, les variables d'instance de ==WithSingleton== sont les mêmes que celles de ==Class==, et elle possède également ==unique== *@fig:RefSing2*.

[[[
Singleton objIVs
>>> #(class name super ivs keywords methodDict unique)
]]]


+Stockage d'une instance unique.>file://figures/Ref-SingletonTwo.pdf|width=55|label=fig:RefSing2+

!!!! Où est stocké le singleton ?

Chaque instance de classe de ==WithSingleton== aura une valeur supplémentaire après son dictionnaire de méthodes. C'est là que le singleton réel de la classe est stocké.
Les classes ==Node== et ==Processor== sont des instances de la métaclasse ==WithSingleton==. Elles ont donc
un champ supplémentaire dans leur structure pour contenir les valeurs uniques des variables d'instance.
Chaque instance de ==WithSingleton== aura sa propre valeur : l'instance de la classe jouant le rôle de singleton.



!!! À propos du 6e postulat

Comme mentionné au début de ce chapitre, le 6ème postulat d'ObjVLisp est erroné. Relisons-le :
''Si les variables d'instance possédées par un objet définissent un environnement local, il existe également des variables de classe définissant un environnement global partagé par toutes les instances d'une même classe. Ces variables de classe sont définies au niveau de la métaclasse selon l'équation suivante : variable de classe [un-objet] = variable d'instance [classe d'un-objet].''

Cela dit que les variables d'instance de classe sont équivalentes à des variables partagées entre les instances, et c'est faux. Voyons cela. Selon le 6ème postulat, une variable partagée entre instances est égale à une variable d'instance de la classe. La définition n'est pas totalement claire, regardons donc un exemple donné dans l'article.

!!!! Illustration du problème
Imaginons que l'on souhaite que le caractère constant '*' soit une variable de classe partagée par tous les points d'une même classe.
Nous redéfinissons la classe ==Point== comme précédemment, mais dont la métaclasse (appelons-la ==MetaPoint==) spécifie ce caractère commun.
Par exemple, si un point a une variable partagée nommée ==char==, cette variable d'instance doit être définie dans la classe de la classe ==Point== appelée ==MetaPoint==. L'auteur propose de définir une nouvelle métaclasse ==MetaPoint== pour contenir une nouvelle variable d'instance pour représenter une variable partagée entre les points.

[[[
Class new
	:name 'MetaPoint'
	:super 'Class'
	:ivs #(char)
]]]

Il propose ensuite de l'utiliser comme suit :

[[[
MetaPoint new
	:name Point
	:super 'Object'
	:ivs #(x y)
	:char '*'
]]]

La classe ==Point== peut définir une méthode qui accède au caractère en passant simplement au niveau de la classe.
Pourquoi cette approche est-elle mauvaise ? Parce qu'elle mélange les niveaux. La variable d'instance ==char== n'est pas une information de classe. Elle décrit les instances terminal et non l'instance de la métaclasse. Pourquoi la ''métaclasse'' ==MetaPoint== aurait-elle besoin d'une variable d'instance ==char== ?

!!!! La solution

La solution consiste à conserver la variable partagée ==char== dans une liste de variables partagées de la classe ==Point==. Toute instance de point peut accéder à cette variable. L'implication est qu'une ''classe'' devrait avoir des informations supplémentaires pour la décrire. C'est-à-dire une variable d'instance ==sharedVariable== contenant des paires, c'est-à-dire la variable et sa valeur.  Nous devrions alors être en mesure d'écrire :

[[[
Class new
	:name Point
	:super 'Object'
	:ivs #(x y)
	:sharedivs {#char -> '*'}
]]]

Par conséquent, la métaclasse ==Class== doit obtenir une variable d'instance supplémentaire nommée ==sharedivs==, et chacune de ses instances (les classes ==Point==, ==Node==, ==Object==) peut avoir différentes ''valeurs''. Ces valeurs peuvent être partagées entre leurs instances par le compilateur.

Ce que nous voyons, c'est que ==sharedivs== fait partie du vocabulaire ==Class== et que nous n'avons pas besoin d'une métaclasse supplémentaire chaque fois que nous voulons partager une
une variable. Cette conception est similaire à celle de Pharo où une classe possède une variable d'instance classVariable contenant des variables partagées dans toutes les sous-classes de la classe qui la définit.

!!! Conclusion

Nous avons présenté un petit noyau composé de deux classes : ==Object==, la racine de l'arbre d'héritage et ==Class==, la première métaclasse racine de l'arbre d'instanciation. Nous avons revu tous les points clés liés à la recherche de méthodes, à la création et à l'initialisation des objets et des classes. Dans le chapitre suivant, nous vous proposons d'implémenter un tel noyau.

!!!! Lectures complémentaires

Le noyau présenté dans ce chapitre est un noyau avec des métaclasses explicites et en tant que tel, il n'est pas une panacée. En effet, il entraîne des problèmes de composition de métaclasses comme expliqué dans l'excellent article de Bouraqadi et al. ${cite:ref=Bour98a}$ ou ${cite:ref=Danf94b}$.