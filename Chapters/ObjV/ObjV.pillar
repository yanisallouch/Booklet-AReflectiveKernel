!!Construction d'un noyau minimal réflexif basé sur des classes

L'objectif de ce chapitre est de vous aider à implémenter pas à pas le modèle ObjVlisp expliqué dans le chapitre précédent.
ObjVlisp a été conçu par Pierre Cointe, qui s'est inspiré du noyau de Smalltalk-78. Il possède des métaclasses explicites et il est composé de deux classes ==Object== et ==Class==.

!!! Objectifs
Au cours du chapitre précédent, vous avez vu les points principaux du modèle ObjVLisp, maintenant vous allez l'implémenter.
Les objectifs de cette implémentation sont de donner une compréhension concrète des concepts présentés précédemment.
Voici quelques points que vous pourrez approfondir en écrivant l'implémentation :

- Quelle est la structure possible d'un objet ?
- Qu'est-ce que l'allocation et l'initialisation des objets ?
- Qu'est-ce que l'initialisation des classes ?
- Quelle est la sémantique de la méthode lookup ?
- Qu'est-ce qu'un noyau réflexif ?
- Quels sont les rôles des classes ==Class== et ==Object== ?
- Quel est le rôle d'une métaclasse ?

!!!Préparation
Dans cette section, nous discutons de la configuration que vous allez utiliser, des choix d'implémentation et des conventions que nous allons suivre tout au long de ce chapitre.

!!!!La mise en place de Pharo
Vous devez télécharger et installer Pharo à partir de *https://pharo.org/*. Vous avez besoin d'une machine virtuelle, de l'image du couple et des modifications. Vous pouvez utiliser *https://get.pharo.org* pour obtenir un script de téléchargement de Pharo.

La version actuelle que vous pouvez utiliser est Pharo 7.0.

[[[
wget -O- get.pharo.org/70+vm | bash
]]]

Vous pouvez utiliser le livre Pharo Par l'Example sur *https://books.pharo.org/pharo-by-example/* pour une vue d'ensemble de la syntaxe et du système.


!!!! Obtenir les définitions de l'infrastructure
Toutes les définitions nécessaires sont fournies sous la forme d'un paquet Monticello. Il contient toutes les classes, les catégories de méthodes et les signatures des méthodes que vous devez implémenter. Il fournit des fonctionnalités supplémentaires telles qu'un inspecteur dédié et quelques méthodes supplémentaires qui vous faciliteront la vie et vous aideront à vous concentrer sur l'essence du modèle. Il contient également tous les tests des fonctionnalités que vous devez implémenter.

Pour charger le code, exécutez l'expression suivante :

[[[
Metacello new
  baseline: 'ObjV';
  repository: 'github://Ducasse/ObjVLispSkeleton/tree/master/src';
  load
]]]

%Alternativement, pour charger le code, ouvrez un navigateur monticello, ajoutez un fichier repository pour pointer vers le projet ObjVLispSkeleton sous ==StephaneDucasse== à *http://www.smalltalkhub.com*.
%Utiliser l'expression suivante dans la pop up de création de dépôt de smalltalkhub, puis sélectionner le dernier fichier et le charger.

%[[[
%MCSmalltalkhubRepository
%    owner: 'StephaneDucasse'
%    project: 'ObjVLispSkeleton'
%    user: ''
%    password: ''
%]]]

!!!! Exécution des tests
Pour chaque fonctionnalité, vous devrez exécuter des tests.

Par exemple, pour exécuter un test particulier nommé ==testPrimitiveStructure==,
- évaluez l'expression ==(ObjTest selector : #testPrimitiveStructure) run==, ou bien
- cliquez sur l'icône de la méthode nommée ==testPrimitiveStructure==.

Notez que puisque vous êtes en train de développer le noyau, pour le tester nous avons implémenté manuellement quelques mocks des classes et du noyau. C'est la méthode de configuration des classes de test qui construisent ce faux noyau. Maintenant, faites attention car les configurations prennent souvent des raccourcis, donc ne les copiez pas aveuglément.



!!! Conventions de nommage
Nous utilisons les conventions suivantes : nous nommons ''primitives'' toutes les méthodes Pharo qui participent à la construction d'ObjVLisp. Ces primitives sont principalement implémentées comme des méthodes de la classe ==Obj==. Notez que dans une implémentation Lisp de telles primitives seraient juste des expressions lambda, dans une implémentation C de telles primitives seraient représentées par des fonctions C.

Pour vous aider à faire la distinction entre les classes dans le langage d'implémentation (Pharo) et le modèle ObjVLisp, nous préfixons toutes les classes ObjVLisp par ==Obj==. Enfin, certaines des primitives cruciales et déroutantes (principalement celles de la structure de classe) sont toutes préfixées par ==obj==. Par exemple, la primitive qui renvoie l'identifiant de classe d'une ''objInstance'' est nommée ==objClassId==.
Nous parlons également d'objInstances, d'objObjects et d'objClasses pour faire référence aux
instances, objets ou classes spécifiques définis dans ObjVLisp.

!!! Hériter de la classe Array

Nous ne voulons pas implémenter un scanner, un parseur et un compilateur pour ObjVLisp mais nous concentrer sur l'essence du langage. C'est pourquoi nous avons choisi d'utiliser autant que possible le langage d'implémentation, ici Pharo. Comme Pharo ne supporte pas la définition de macro, nous utiliserons autant que possible les classes existantes pour éviter des problèmes syntaxiques supplémentaires.


Dans notre implémentation, chaque objet dans le monde ObjVLisp est une instance de la classe ==Obj==.
La classe ==Obj== est une sous-classe de ==Array==.

Puisque ==Obj== est une sous-classe de ==Array==, ==#(#ObjPoint 10 15)== est une objInstance de la classe ==ObjPoint== qui est aussi une instance de array de la classe Pharo ==ObjClass==.

Comme nous allons le voir :
- ==#(#ObjPoint 10 15)== représente un objPoint (10,15). C'est une objInstance de la classe ==ObjPoint==.
- ==#(#ObjClass #ObjPoint #ObjObject #(class x y) #(:x :y) nil )== est le tableau qui représente l'objclass ==ObjPoint==.

!!!! À propos des choix de représentation
Vous pouvez sauter cette discussion lors d'une première lecture. Nous aurions pu implémenter la fonctionnalité ObjVLisp au niveau d'une classe nommée ==Obj== héritant simplement de ==Object==. Cependant, pour utiliser la primitive ObjVlisp (une méthode Pharo) ==objInstanceVariableValue : anObject for : anInstanceVariable== qui renvoie la valeur de la variable d'instance dans ==anObject==, nous aurions été obligés d'écrire l'expression suivante :

[[[
Obj objInstanceVariableValue: 'x' for: aPoint
]]]

Nous avons choisi de représenter tout objet ObjVLisp par un tableau et de définir la fonctionnalité ObjVLisp dans le côté instance de la classe ==Obj== (une sous-classe de ==Array==). De cette façon, nous pouvons écrire de manière plus naturelle et plus lisible la fonctionnalité précédente comme suit :

[[[
aPoint objInstanceVariableValue: 'x'.
]]]

!!! Faciliter l'accès à la classe objclass

Nous avons besoin d'un moyen de stocker et d'accéder aux classes ObjVLisp. Comme
solution, au niveau de la classe Pharo ==Obj== nous avons défini un
dictionnaire contenant les classes définies. Ce dictionnaire fait office d'espace de noms pour notre langage. Nous avons défini les méthodes suivantes pour stocker et accéder aux classes définies.

- ==declareClass: anObjClass== stocke l'objInstance ==anObjClass== donnée en argument dans le référentiel de classes (ici un dictionnaire dont les clés sont les noms de classes et les valeurs les classes ObjVLisp elles-mêmes).

- ==giveClassNamed: aSymbol== renvoie la classe ObjVLisp nommée ==aSymbol== si elle existe. La classe doit avoir été déclarée auparavant.

Avec de telles méthodes, nous pouvons écrire du code comme le suivant qui recherche la classe de la classe ==ObjPoint==.

[[[testcase=true
Obj giveClassNamed: #ObjPoint
>>> #(#ObjClass 'ObjPoint' #ObjObject #(class x y) #(:x :y) ... )
]]]

Pour rendre l'accès aux classes moins lourd, nous avons également implémenté un raccourci :
Nous piégeons les messages non compris envoyés à ==Obj== et consultons le dictionnaire des classes définies.
Puisque ==ObjPoint== est un message inconnu, ce même code est alors écrit comme :

[[[testcase=true
Obj ObjPoint
>>> #(#ObjClass 'ObjPoint' #ObjObject #(class x y) #(:x :y) ... )
]]]

Maintenant vous êtes prêt à commencer.


!!! Structure et primitives

La première question est de savoir comment représenter les objets. Nous devons nous mettre d'accord sur une représentation initiale. Dans cette implémentation, nous avons choisi de représenter les objInstances comme des tableaux (instances de ==Obj== une sous-classe de ==Array==). Dans ce qui suit, nous utilisons le terme tableau pour parler des instances de la classe ==Obj==.

!!!! Votre travail.
Vérifiez que la classe ==Obj== existe et hérite de ==Array==.

!!! Structure d'une classe
Le premier objet que nous allons créer est la classe ==ObjClass==. Par conséquent, nous nous
nous concentrons maintenant sur la structure minimale des classes de notre langage.

Une objInstance représentant une classe a la structure suivante : un identifiant de sa classe, un nom, un identifiant de sa superclasse (nous limitons le modèle à l'héritage simple), une liste de variables d'instance, une liste de mots-clés d'initialisation, et un dictionnaire de méthodes.

Par exemple la classe ==ObjPoint== a donc la structure suivante :

[[[
#(#ObjClass #ObjPoint #ObjObject #(class x y) #(:x :y) nil)
]]]


Cela signifie que ==ObjPoint== est une instance de ==ObjClass==, est nommé ==#ObjPoint==, hérite d'une classe nommée ==ObjObject==, possède trois variables d'instance, deux mots-clés d'initialisation et un dictionnaire de méthodes non initialisées. Pour accéder à cette structure, nous définissons quelques primitives comme le montre la figure *@fig:structure*.
La figure *@fig:offset* montre comment les offsets sont utilisés pour accéder de manière contrôlée aux informations brutes de objClass.

+Représentation de la structure de la classe.>file://figures/ClassRepresentationAsArray.pdf|width=60|label=fig:structure+

+Utilisation du décalage pour accéder à l'information.>file://figures/AccessObjName.pdf|width=60|label=fig:offset+


!!!! Votre travail.

 Les méthodes de test de la classe ==RawObjTest== qui sont dans les catégories =='step1-tests-structure of objects'== et =='step2-tests-structure of classes'== donnent quelques exemples d'accès à la structure.

[[[
RawObjTest >> testPrimitiveStructureObjClassId
   "(self selector: #testPrimitiveStructureObjClassId) run"

   self assert: (pointClass objClassId = #ObjClass).
]]]

[[[
RawObjTest >> testPrimitiveStructureObjIVs
   "(self selector: #testPrimitiveStructureObjIVs) run"

   self assert: ((pointClass objIVs) = #(#class #x #y)).
]]]


Implémentez les primitives manquantes pour exécuter les tests suivants ==testPrimitiveStructureObjClassId==,
 ==testPrimitiveStructureObjIVs==, ==testPrimitiveStructureObjKeywords==,
 ==testPrimitiveStructureObjMethodDict==, ==testPrimitiveStructureObjName==, and ==testPrimitiveStructureObjSuperclassId==.

Vous pouvez les exécuter en sélectionnant l'expression suivante ==(RawObjTest selector :
 #testPrimitiveStructureObjClassId) run==. Notez que les tableaux commencent à 1 dans Pharo. Vous trouverez ci-dessous la liste des primitives que vous devez implémenter.

Implémentez dans le protocole =='object structure primitives'== les primitives qui gèrent :
- la classe de l'instance représentée par un symbole. ==objClassId==, ==objClassId : aSymbol==. Le receveur est un ==objObject==. Cela signifie que cette primitive peut être appliquée sur n'importe quel objInstance pour obtenir son identifiant de classe.

Implémenter dans le protocole =='class structure primitives'== les primitives qui gèrent :
- le nom de la classe : ==objName==, ==objName : aSymbol==. Le receveur est un objClass.
- la superclasse : ==objSuperclassId==, ==objSuperclassId : aSymbol==. Le receveur est un objClass.
- les variables d'instance : ==objIVs==, ==objIVs : anOrderedCollection==. Le receveur est un objClass.
- la liste des mots-clés : ==objKeywords==, ==objKeywords : anOrderedCollection==. Le receveur est un objClass.
- le dictionnaire de méthodes : ==objMethodDict==, ==objMethodDict : anIdentityDictionary==. Le receveur est un objClass.





!!! Trouver la classe d'un objet
Chaque objet conserve l'identifiant de sa classe (son nom). Par exemple, une instance de ==ObjPoint== a alors la structure suivante : ==#(#ObjPoint 10 15)== où ==#ObjPoint== est un symbole identifiant la classe ==ObjPoint==.

!!!! Votre travail.

En utilisant la primitive ==giveClassNamed : aSymbol== définie au niveau de la classe Obj, définissez la primitive ==objClass== dans le protocole =='object-structure primitive'== qui renvoie l'objInstance qui représente sa classe (les classes sont aussi des objets dans ObjVLisp).

Assurez-vous que vous exécutez la méthode de test : ==testClassAccess==

[[[
RawObjTest >> testClassAccess
   "(self selector: #testClassAccess) run"

   self assert: (aPoint objClass = pointClass)
]]]

Nous sommes maintenant prêts à manipuler les objInstances via l'API appropriée. Nous allons maintenant utiliser la classe ==ObjTest== pour des tests plus élaborés.


!!! Accès aux valeurs des variables d'instance des objets

+Décalage de la variable d'instance demandé à la classe.>file://figures/offsetFromClass.pdf|width=60|label=fig:offset2+

!!!! Une première méthode simple.
Le test suivant illustre le comportement du message ==offsetFromClassOfInstanceVariable:==.

[[[
ObjTest >> testIVOffset
   "(self  selector: #testIVOffset) run"

   self assert: ((pointClass offsetFromClassOfInstanceVariable: #x) = 2).
   self assert: ((pointClass offsetFromClassOfInstanceVariable: #lulu) = 0)
]]]

!!!! Votre travail.
Dans le protocole =='iv management'== définissez une méthode appelée ==offsetFromClassOfInstanceVariable : aSymbol== qui renvoie le décalage de la variable d'instance représentée par le symbole donné en paramètre. Elle renvoie 0 si la variable n'est pas définie. Consultez les tests ==#testIVOffset== de la classe ==ObjTest==.

Conseils : Utilisez la méthode Pharo ==indexOf:==. Faites attention à ce qu'une telle primitive soit appliquée à une objClass comme indiqué dans le test.

Assurez-vous que vous exécutez la méthode de test : ==testIVOffset==.

+L'offset de la variable d'instance demandé à l'instance elle-même.>file://figures/offsetFromObject.pdf|width=60|label=fig:offset3+

!!!! Une deuxième méthode simple.

Le test suivant illustre le comportement attendu

[[[
ObjTest >> testIVOffsetAndValue
   "(self  selector: #testIVOffsetAndValue) run"

   self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x) = 2).
   self assert: ((aPoint valueOfInstanceVariable: #x) = 10)
]]]


!!!! Votre travail.
En utilisant la méthode précédente, définissez dans le protocole =='iv management'== :
# la méthode ==offsetFromObjectOfInstanceVariable : aSymbol== qui retourne le décalage de la variable d'instance. Notez que cette fois-ci la méthode est appliquée à une objInstance présentant une instance et non une classe (comme le montre la figure *@fig:offset3*).
# la méthode ==valueOfInstanceVariable : aSymbol== qui retourne la valeur de cette variable d'instance dans l'objet donné comme le montre le test ci-dessous.

Notez que pour la méthode ==offsetFromObjectOfInstanceVariable:==, vous pouvez vérifier que la variable d'instance existe dans la classe de l'objet et, sinon, soulever une erreur en utilisant la méthode Pharo ==error:==.

Assurez-vous que vous exécutez la méthode de test : ==testIVOffsetAndValue== et qu'elle passe.


!!! Allocation et initialisation des objets

La création d'un objet est la composition de deux opérations élémentaires : son ''allocation'' et son ''initialisation''.
Nous définissons maintenant les primitives qui nous permettent d'allouer et d'initialiser un objet. Rappelons que
- l'allocation est une méthode de classe qui retourne une structure presque vide, presque vide car l'instance représentée par la structure doit au moins connaître sa classe, et que
- l'initialisation est une méthode d'instance qui, étant donné une instance nouvellement allouée et une liste d'arguments d'initialisation, remplit l'instance.

!!!! Allocation d'instance

Comme le montre la classe ==ObjTest==, si la classe ==ObjPoint== possède deux variables d'instance : ==ObjPoint allocateAnInstance== renvoie ==#(#ObjPoint nil nil)==.

[[[
ObjTest >> testAllocate
   "(self  selector: #testAllocate) run"
   | newInstance |
   newInstance := pointClass allocateAnInstance.
   self assert: (newInstance at: 1) = #ObjPoint.
   self assert: (newInstance size) = 3.
   self assert: (newInstance at: 2) isNil.
   self assert: (newInstance at: 3) isNil.
   self assert: (newInstance objClass = pointClass)
]]]


!!!! Votre travail.
Dans le protocole =='instance allocation'== implémentez la primitive appelée ==allocateAnInstance== qui envoyée à un ''objClass'' retourne une nouvelle instance dont les valeurs des variables d'instance sont nil et dont l'objClassId représente l'objClass.


Assurez-vous que vous exécutez la méthode de test : ==testAllocate==.

!!! Primitives de mots-clés

L'implémentation originale d'ObjVLisp utilise la facilité offerte par les mots-clés Lisp pour faciliter la spécification des valeurs des variables d'instance pendant la création de l'instance. Elle fournit également un moyen uniforme et unique de créer des objets.
Nous devons implémenter certaines fonctionnalités pour supporter les mots-clés. Cependant,
, comme ce n'est pas vraiment intéressant et que vous perdez du temps, nous vous donnons
toutes les primitives nécessaires.

!!!! Votre travail.
Toutes les fonctionnalités pour gérer les mots-clés sont définies dans le protocole =='keyword management'==. Lisez le code et le test associé appelé ==testKeywords== dans la classe ==ObjTest==.

[[[
ObjTest >> testKeywords
   "(self  selector: #testKeywords) run"

   | dummyObject |
   dummyObject := Obj new.
   self assert:
      ((dummyObject generateKeywords: #(#titi #toto #lulu))
        = #(#titi: #toto: #lulu:)).
   self assert:
      ((dummyObject keywordValue: #x
          getFrom: #(#toto 33 #x 23)
          ifAbsent: 2) = 23).
   self assert:
      ((dummyObject keywordValue: #x
         getFrom: #(#toto 23)
         ifAbsent: 2) = 2).
   self assert:
      ((dummyObject returnValuesFrom: #(#x 22 #y 35) followingSchema: #(#y #yy #x #y))
         = #(35 nil 22 35))
]]]

Assurez-vous que vous exécutez la méthode de test : ==testKeywords== et qu'elle passe.

!!! Initialisation des objets
Une fois qu'un objet est alloué, il peut être initialisé par le programmeur en spécifiant une liste de valeurs d'initialisation. On peut représenter une telle liste par un tableau contenant alternativement
un mot-clé et une valeur comme ==#(#toto 33 #x 23)== où 33 est associé à ==#toto== et 23 à ==#x==.

!!!! Votre travail.
Lire dans le protocole =='instance initialization'== la primitive ==initializeUsing : anArray== qui, lorsqu'elle est envoyée à un objet avec une liste d'initialisation, renvoie l'objet initialisé.

[[[
ObjTest >> testInitialize
   "(self  selector: #testInitialize) run"

   | newInstance  |
   newInstance := pointClass allocateAnInstance.
   newInstance initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).
   self assert: (newInstance at: 1) equals: #ObjPoint.
   self assert: (newInstance at: 2) equals: 1.
   self assert: (newInstance at: 3) equals: 2.
]]]

!!! Héritage statique des variables d'instance

Les variables d'instance sont héritées statiquement au moment de la création de la classe.
La forme la plus simple de l'héritage des variables d'instance est de définir l'ensemble complet des variables d'instance comme la ''fusion ordonnée'' entre les variables d'instance héritées et les variables d'instance définies localement.
Pour des raisons de simplicité et de similitude avec la plupart des langages, nous avons choisi d'interdire les variables d'instance dupliquées dans la chaîne d'héritage.

!!!! Votre travail.
Dans le protocole =='iv inheritance'==, lisez et comprenez la primitive ==computeNewIVFrom : superIVOrdCol with : localIVOrdCol==.

La primitive prend deux collections ordonnées de symboles et retourne une collection ordonnée contenant l'union des deux collections ordonnées mais avec la contrainte supplémentaire que l'ordre des éléments de la première collection ordonnée est conservé. Regardez la méthode de test ==testInstanceVariableInheritance== ci-dessous pour des exemples.

Assurez-vous que vous exécutez la méthode de test : ==testInstanceVariableInheritance== et qu'elle passe.

[[[
ObjTest >> testInstanceVariableInheritance
   "(self  selector: #testInstanceVariableInheritance) run"

   "a better choice would be to throw an exception if there are duplicates"
   self assert:
      ((Obj new computeNewIVFrom: #(#a #b #c #d) asOrderedCollection
         with: #(#a #z #b #t) asOrderedCollection)
         = #(#a #b #c #d #z #t) asOrderedCollection).
   self assert:
      ((Obj new computeNewIVFrom: #() asOrderedCollection
         with: #(#a #z #b #t) asOrderedCollection)
         = #(#a #z #b #t) asOrderedCollection)
]]]

!!!!Remarque annexe
On pourrait penser que garder le même ordre des variables d'instance entre une superclasse et sa sous-classe n'est pas un problème. C'est en partie vrai dans cette implémentation simple car les accesseurs de variables d'instance calculent à chaque fois le décalage correspondant pour accéder à une variable d'instance en utilisant la primitive ==offsetFromClassOfInstanceVariable:==. Cependant, la structure (ordre des variables d'instance) d'une classe est codée en dur par les primitives. C'est pourquoi votre implémentation de la primitive ==computeNewIVFrom:with:== doit prendre en charge cet aspect.

!!!Gestion des méthodes
Une classe stocke le comportement (exprimé par des méthodes) partagé par toutes ses instances dans un dictionnaire de méthodes.
Dans notre implémentation, nous représentons les méthodes en associant un symbole à un ''bloc'' Pharo, une sorte de méthode anonyme.
Le bloc est ensuite stocké dans le dictionnaire de méthodes d'une objClass.

Dans cette implémentation, nous n'offrons pas la possibilité d'accéder directement aux variables d'instance de la classe dans laquelle la méthode est définie.
Cela pourrait être fait en partageant un environnement commun entre toutes les méthodes.
Le programmeur doit utiliser des accesseurs ou les méthodes ==setIV== et ==getIV== objMethods définies sur ==ObjObject== pour accéder aux variables d'instance.
Vous pouvez trouver la définition de ces méthodes dans le protocole d'amorçage du côté de la classe de ==Obj==.

Dans notre implémentation d'ObjVLisp, nous n'avons pas de syntaxe pour le passage de messages. Au lieu de cela, nous appelons les primitives en utilisant la syntaxe Pharo pour le passage de messages (en utilisant le message ==send:withArguments:==).
L'expression ==objself getIV : x== est exprimée en ObjVLisp comme suit
==objself send: #getIV withArguments: #(#x)==.


Le code suivant décrit la définition de la méthode accesseur ==x== définie sur l'objClass ==ObjPoint== qui invoque un accès au champ en utilisant le message ==getIV==.

[[[
ObjPoint
   addUnaryMethod: #accessInstanceVariableX
   withBody: 'objself send: #getIV withArguments: #(#x)'.
]]]

En première approximation, ce code créera le bloc suivant qui sera stocké dans le dictionnaire des méthodes de la classe : ==[ :objself | objself send: #getIV withArguments: #(#x) ]==.
Comme vous pouvez le remarquer, dans notre implémentation, le receveur est toujours un argument explicite de la méthode. Ici, nous l'avons nommé ==objself==.

!!!! Définition d'une méthode et envoi d'un message

Comme nous voulons garder cette implémentation aussi simple que possible, nous ne définissons qu'une seule primitive pour l'envoi d'un message : il s'agit de ==send:withArguments:==. Pour voir la correspondance entre les manières Pharo et ObjVlisp d'exprimer l'envoi d'un message, regardez la comparaison ci-dessous :

[[[
Pharo Unary: self odd
ObjVLisp: objself send: #odd withArguments: #()

Pharo Binary: a + 4
ObjVLisp: a send: #+ withArguments: #(4)

Pharo Keyword: a max: 4
ObjVLisp: a send: #max: withArguments: #(4)
]]]


Alors qu'en Pharo, vous écririez la définition de méthode suivante :
[[[
bar: x
   self foo: x
]]]

Dans notre implémentation de ObjVlisp vous écrivez :
[[[
anObjClass
   addMethod: #bar:
   args: 'x'
   withBody: 'objself send: #foo: withArguments: #x'.
]]]


!!!! Votre travail.
Nous fournissons toutes les primitives qui gèrent la définition des méthodes.
Dans le protocole =='gestion des méthodes'== regardez les méthodes ==addMethod : aSelector args : aString withBody : aStringBlock==,
==removeMethod : aSelector== et ==doesUnderstand : aSelector==. Mettez en œuvre ==bodyOfMethod : aSelector==.

Assurez-vous que vous exécutez la méthode de test : ==testMethodManagement==

[[[
ObjTest >> testMethodManagement
   "(self  selector: #testMethodManagment) run"
   self assert: (pointClass doesUnderstand: #x).
   self assert: (pointClass doesUnderstand: #xx) not.

   pointClass
      addMethod: #xx
      args: ''
      withBody: 'objself valueOfInstanceVariable: #x '.
   self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).
   self assert: (pointClass doesUnderstand: #xx).
   pointClass removeMethod: #xx.
   self assert: (pointClass doesUnderstand: #xx) not.
   self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)
]]]

!!! Passage de messages et recherche dynamique

L'envoi d'un message est le résultat de la composition de la ''recherche de méthode'' et de l''exécution''. La primitive ==basicSend:withArguments:from:== suivante ne fait que l'implémenter.
Tout d'abord, elle recherche la méthode dans la classe ou la superclasse du receveur, si la
méthode a été trouvée, elle l'exécute, sinon ==lookup:== retourne nil et nous levons une erreur Pharo.

[[[
Obj >> basicSend: selector withArguments: arguments from: aClass
   "Execute the method found starting from aClass and whose name is selector.
   The core of the sending a message, reused for both a normal send or a super one."
   | methodOrNil |
   methodOrNil := aClass lookup: selector.
   ^ methodOrNil
      ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ]
      ifNil: [ Error signal: 'Obj message' , selector asString, ' not understood' ]
]]]

Sur la base de cette primitive, nous pouvons exprimer ==send:withArguments:== comme suit :

[[[
Obj >> send: selector withArguments: arguments
   "send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is looked up in the class of the receiver. self is an objObject or a objClass."

   ^ self basicSend: selector withArguments: arguments from:  self objClass
]]]


!!!Recherche de méthode
La primitive ==lookup : selector== appliquée à une objClass doit retourner la méthode associée au sélecteur si elle l'a trouvée, sinon nil pour indiquer qu'elle a échoué.

!!!! Votre travail.
Implémenter la primitive ==lookup : selector== qui, envoyée à un objClass avec un sélecteur de méthode, un symbole et le receveur initial du message, retourne le corps de la méthode associée au sélecteur dans l'objClass ou ses superclasses.  De plus, si la méthode n'est pas trouvée, nil est retourné.

Assurez-vous d'exécuter les méthodes de test : ==testNilWhenErrorInLookup== et ==testRaisesErrorSendWhenErrorInLookup== dont le code est donné ci-dessous :

[[[
ObjTest >> testNilWhenErrorInLookup
   "(self  selector: #testNilWhenErrorInLookup) run"

   self assert: (pointClass lookup: #zork) isNil.
   "The method zork is NOT implement on pointClass"
]]]


[[[
ObjTest >> testRaisesErrorSendWhenErrorInLookup
   "(self  selector: #testRaisesErrorSendWhenErrorInLookup) run"

   self should: [ pointClass send: #zork withArguments: { aPoint } ] raise: Error.
   "Open a Transcript to see the message trace"
]]]


!! Gestion de super

Pour invoquer une méthode cachée d'une superclasse, en Java et Pharo vous utilisez ==super==, ce qui signifie que la recherche commencera au-dessus de la classe définissant la méthode contenant l'expression super. En fait, nous pouvons considérer qu'en Java ou Pharo, super est un sucre syntaxique pour se référer au receveur mais en changeant l'endroit où la recherche de la méthode commence. C'est ce que nous voyons dans notre implémentation où nous n'avons pas de support syntaxique.

Voyons comment nous allons exprimer la situation suivante.
[[[
bar: x
   super foo: x
]]]

Dans notre implémentation de ObjVlisp, nous n'avons pas de construction syntaxique pour exprimer super, vous devez utiliser le message ==super:withArguments:== de Pharo comme suit.

[[[
anObjClass
  addMethod: #bar:
  args: 'x'
  withBody: 'objself super: #foo: withArguments: #(#x) from: superClassOfClassDefiningTheMethod'.
]]]

Notez que ==superClassOfClassDefiningTheMethod== est une variable liée à la superclasse de ==anObjClass==, c'est-à-dire la classe définissant la méthode ==bar== (voir plus loin).

[[[
Pharo Unary: super odd
ObjVLisp:  objself super: #odd withArguments: #() from: superClassOfClassDefiningTheMethod

Pharo Binary: super + 4
ObjVLisp: objself super: #+ withArguments: #(4) from: superClassOfClassDefiningTheMethod

Pharo Keyword: super max: 4
ObjVlisp: objself super: #max: withArguments: #(4) from: superClassOfClassDefiningTheMethod
]]]

!!! Représentation de super
Nous aimerions vous expliquer d'où vient la variable ==superClassOfClassDefiningTheMethod==.
Lorsque nous comparons la primitive ==send:withArguments:==, pour les super envois nous avons ajouté un troisième paramètre à la primitive et nous l'avons appelé ==super:withArguments:from:==.

Ce paramètre supplémentaire correspond à la superclasse de la classe dans laquelle la méthode est définie. Cet argument doit toujours avoir le même nom, c'est-à-dire ==superClassOfClassDefiningTheMethod==. Cette variable sera liée lorsque la méthode sera ajoutée dans le dictionnaire des méthodes d'une objClass.

Si vous voulez comprendre comment nous lions la variable, voici l'explication :
En fait, une méthode n'est pas seulement un bloc mais elle a besoin de connaître la classe qui la définit ou sa superclasse. Nous avons ajouté cette information en utilisant la curryfication. (une curryfication est la transformation d'une fonction à n arguments en fonction avec moins d'argument mais une capture d'environnement : ==f(x,y)= (+ x y)== est transformée en une fonction ==f(x)=f(y)(+ x y)== qui retourne une fonction d'un seul argument y et où x est lié à une valeur et obtient un générateur de fonction). Par exemple, ==f(2,y)== renvoie une fonction ==f(y)=(+ 2 y)== qui ajoute son paramètre à 2. Une curryfication agit comme un générateur de fonction où l'un des arguments de la fonction originale est fixé.

Dans Pharo, nous enveloppons le bloc représentant la méthode autour d'un autre bloc avec un seul paramètre et nous lions ce paramètre avec la superclasse de la classe définissant la méthode. Lorsque la méthode est ajoutée au dictionnaire des méthodes, nous évaluons le premier bloc avec la superclasse comme paramètre, comme illustré ci-dessous :

[[[
method := [ :superClassOfClassDefiningTheMethod |
     [ :objself :otherArgs  |
           ... method code ...
           ]]
method value: (Obj giveClassNamed: self objSuperclassId)
]]]

Vous savez donc maintenant d'où vient la variable ==superClassOfClassDefiningTheMethod==.
Assurez-vous que vous exécutez la méthode de test : ==testMethodLookup== et qu'elle passe.

!!!! Votre travail.
Vous devriez maintenant mettre en œuvre ==super : selector withArguments : arguments from : aSuperclass== en utilisant la primitive ==basicSend:withArguments:from:==.

!!!Gestion des messages non compris

Nous pouvons maintenant revoir la gestion des erreurs. Au lieu de générer une erreur Pharo, nous voulons envoyer un message ObjVlisp au destinataire du message pour lui donner une chance de détecter l'erreur.

Comparez les deux versions suivantes de ==basicSend : selector withArguments : arguments from : aClass== et proposez une implémentation de ==sendError : selector withArgs : arguments==.

[[[
Obj >> basicSend: selector withArguments: arguments from: aClass
   | methodOrNil |
   methodOrNil := (aClass lookup: selector).
   ^ methodOrNil
      ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ]
      ifNil: [ Error signal: 'Obj message' , selector asString, ' not understood' ]
]]]


[[[
Obj >> basicSend: selector withArguments: arguments from: aClass
   | methodOrNil |
   methodOrNil := (aClass lookup: selector).
   ^ methodOrNil
      ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ]
      ifNil: [ self sendError: selector withArgs: arguments ]
]]]

Il convient de noter que la méthode objVlisp est définie comme suit dans la classe ==ObjObject== (voir la méthode bootstrap du côté de la classe Obj). La méthode obj ==error== attend un seul paramètre : un tableau d'arguments dont le premier élément est le sélecteur du message non compris.

[[[
objObject
   addMethod: #error
   args: 'arrayOfArguments'
   withBody: 'Transcript show: ''error '', arrayOfArguments first.  ''error '', arrayOfArguments first'.
]]]

[[[
Obj >> sendError: selector withArgs: arguments
   "send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."

   ^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}
]]]

Assurez-vous de lire et d'exécuter la méthode de test : ==testSendErrorRaisesErrorSendWhenErrorInLookup==.
Regardez l'implémentation de la méthode ==#error== définie dans ==ObjObject== et dans ==assembleObjectClass== de la classe ObjTest.



!! Amorçage du système

Maintenant que vous avez implémenté tous les comportements dont nous avons besoin, vous êtes prêt à amorcer le système : cela signifie créer le noyau constitué des classes ==ObjObject== et ==ObjClass== à partir d'elles-mêmes. L'idée d'un bootstrap intelligent est d'être aussi paresseux que possible et d'utiliser le système pour se créer lui-même en créant rapidement une première classe fausse mais fonctionnelle avec laquelle nous construirons le reste.

Trois étapes composent le bootstrap ObjVlisp,
# nous créons à la main la partie minimale de l'objClass ==ObjClass== et ensuite
# nous l'utilisons pour créer normalement ==ObjObject== objClass et ensuite
# nous recréons normalement et complètement ==ObjClass==.

Ces trois étapes sont décrites par la méthode bootstrap suivante de la classe Obj.
Notez que le bootstrap est défini comme les méthodes de la classe Obj.

[[[
Obj class >> bootstrap
      "self bootstrap"

      self initialize.
      self manuallyCreateObjClass.
      self createObjObject.
      self createObjClass.
]]]

Pour vous aider à implémenter la fonctionnalité des classes d'objets ==ObjClass== et
==ObjObject==, nous avons défini un autre ensemble de tests dans la classe ==ObjTestBootstrap==.
Lisez-les.

!!! Création manuelle de la classe ObjClass

La première étape consiste à créer manuellement la classe ==ObjClass==. Par manuellement, nous entendons créer un tableau (car nous avons choisi un tableau pour représenter les instances et les classes en particulier) qui représente l'objClass ==ObjClass==, puis définir ses méthodes. Vous implémenterez/liserez ceci dans la primitive ==manuallyCreateObjClass== comme indiqué ci-dessous :

[[[
Obj class >> manuallyCreateObjClass
  "self manuallyCreateObjClass"

  | class |
  class := self manualObjClassStructure.
  Obj declareClass: class.
  self defineManualInitializeMethodIn: class.
  self defineAllocateMethodIn: class.
  self defineNewMethodIn: class.
  ^ class
]]]



Pour cela, vous devez implémenter/lire toutes les primitives qui le
le composent.

!!!! Votre travail.
Au niveau de la classe dans le protocole =='bootstrap objClass manual'== lire ou implémenter :
la primitive ==manualObjClassStructure== qui renvoie un objObject qui représente la classe ==ObjClass==.

Assurez-vous d'exécuter la méthode de test : ==testManuallyCreateObjClassStructure==.

- Comme le ==initialize== de cette première phase du bootstrap n'est pas facile nous vous donnons son code. Notez que la définition de l'objMethod ==initialize== est faite dans la méthode primitive ==defineManualInitializeMethodIn:==.

[[[
Obj class >> defineManualInitializeMethodIn: class

   class
    addMethod: #initialize
    args: 'initArray'
    withBody:
      '| objsuperclass |
      objself initializeUsing: initArray.  "Initialize a class as an object. In the bootstrapped system will be done via super"
      objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].
      objsuperclass isNil
        ifFalse:
          [ objself
            objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]
        ifTrue:
          [ objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].
      objself
        objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).
      objself objMethodDict: (IdentityDictionary new: 3).
      Obj declareClass: objself.
      objself'
]]]

Notez que cette méthode fonctionne sans héritage puisque la classe ==ObjObject==
n'existe pas encore.

La primitive ==defineAllocateMethodIn : anObjClass== définit dans unObjClass passé en argument la méthode ==allocate==. ==allocate== ne prend qu'un seul argument : la classe pour laquelle une nouvelle instance est créée comme indiqué ci-dessous :

[[[
defineAllocateMethodIn: class

   class
      addUnaryMethod: #allocate
      withBody: 'objself allocateAnInstance'
]]]

Suivant le même principe, définissez la primitive ==defineNewMethodIn : anObjClass== qui définit dans uneObjClass passée en argument l'objMethod ==new==. ==new== prend deux arguments : une classe et une initargs-list. Elle doit invoquer les méthodes objMethod ==allocate== et ==initialize==.

!!!! Votre travail.

Assurez-vous de lire et d'exécuter la méthode de test : ==testManuallyCreateObjClassAllocate==.

!!!! Remarques
Lisez attentivement les remarques ci-dessous et le code.
- Dans la méthode objMethod ==manualObjClassStructure==, l'héritage des variables d'instance est simulé. En effet, le tableau de variables d'instance contient ==#class== qui devrait normalement être hérité de ==ObjObject== comme nous le verrons dans la troisième phase du bootstrap.

- Notez que la classe est déclarée dans le référentiel de classes à l'aide de la méthode ==declareClass:==.

- Notez que la méthode ==#initialize== est une méthode de la métaclasse ==ObjClass== : lorsque vous créez une classe, la méthode initialize est invoquée sur une classe ! La méthode ==initialize== définie sur la métaclasse ==ObjClass== a deux aspects : le premier concerne l'initialisation de la classe comme toute autre instance (première ligne). Ce comportement est normalement réalisé en utilisant un super appel pour invoquer la méthode ==initialize== définie dans ==ObjObject==. La version finale de la méthode ==initialize== le fera en utilisant perform. La seconde traite de l'initialisation des classes : effectuer l'héritage des variables d'instance, puis calculer les mots-clés de la classe nouvellement créée. Notez dans cette dernière étape que le tableau de mots-clés ne contient pas le mot-clé ==#class:== car nous ne voulons pas laisser l'utilisateur modifier la classe d'un objet.


!!!Création d'un ObjObject

Vous êtes maintenant dans la situation où vous pouvez créer la première classe réelle et normale du système : la classe ==ObjObject==. Pour ce faire, vous envoyez le message ==new== à la classe ==ObjClass== en spécifiant que la classe que vous créez est nommée ==#ObjObject== et
que vous n'avez qu'une seule variable d'instance appelée ==class==. Vous ajouterez ensuite les méthodes définissant le comportement partagé par tous les objets.

!!!! Votre travail : objObjectStructure
Implémentez/lisez la primitive suivante ==objObjectStructure== qui crée le ==ObjObject== en invoquant le message ==new== à la classe ==ObjClass== :

[[[
Obj class >> objObjectStructure

   ^ (self giveClassNamed: #ObjClass)
      send: #new
      withArguments: #(#(#name: #ObjObject #iv: #(#class)))
]]]

La classe ==ObjObject== est nommée ==ObjObject==, possède une seule variable d'instance ==class== et n'a pas de superclasse car elle est la racine du graphe d'héritage.

!!!! Votre travail : createObjObject

Implémentez maintenant la primitive ==createObjObject== qui appelle ==objObjectStructure== pour obtenir le ==objObject== représentant
la classe ==objObject== et y définir des méthodes. Pour vous aider, nous donnons ici le début d'une telle méthode

[[[
Obj class >> createObjObject
   | objObject |
   objObject := self objObjectStructure.
   objObject addUnaryMethod: #class withBody: 'objself objClass'.
   objObject addUnaryMethod: #isClass withBody: 'false'.
   objObject addUnaryMethod: #isMetaclass withBody: 'false'.
   ...
   ...
   ^ objObject
]]]

Implémenter les méthodes suivantes dans ==ObjObject==
- l'objMethod ==class== qui, étant donné une objInstance, retourne sa classe (l'objInstance qui représente la classe).
- l'objMethod ==isClass== qui renvoie false.
- l'objMethod ==isMetaClass== qui renvoie false.
- l'objMethod ==error== qui prend deux arguments : le receveur et le sélecteur de l'invocation originale et qui lève une erreur.
- l'objMethod ==getIV== qui prend le receveur et un nom d'attribut, aSymbol, et renvoie sa valeur pour le receveur.
- L'objMethod ==setIV== qui prend le receveur, un nom d'attribut et une valeur et définit la valeur de l'attribut donné à la valeur donnée.
- l'objMethod ==initialize== qui prend le receveur et une initargs-list et initialise le receveur selon la spécification donnée par l'initargs-list. Notez qu'ici, la méthode ==initialize== ne fait que remplir l'instance conformément à la spécification donnée par la liste d'initargs. Comparez avec la méthode ==initialize== définie sur ==ObjClass==.

Assurez-vous de lire et d'exécuter la méthode de test : ==testCreateObjObjectStructure==.

Remarquez en particulier que cette classe n'implémente pas la méthode de classe ==new== parce qu'elle n'est pas une métaclasse, mais qu'elle implémente la méthode d'instance ==initialize== parce que tout objet doit être initialisé.

!!!! Votre travail : exécuter les tests
- Assurez-vous de lire et d'exécuter la méthode de test : ==testCreateObjObjectMessage==.
- Assurez-vous que vous lisez et exécutez la méthode de test : ==testCreateObjObjectInstanceMessage==.


!!! Création de la classe ObjClass

En suivant la même démarche, vous pouvez maintenant recréer complètement la classe ==ObjClass==. La primitive ==createObjClass== est chargée de créer la classe finale ==ObjClass==. Vous allez donc l'implémenter et définir toutes les primitives dont elle a besoin. Maintenant nous ne définissons que ce qui est spécifique aux classes, le reste est hérité de la superclasse de la classe ==ObjClass==, la classe ==ObjObject==.

[[[
Obj class >> createObjClass
   "self bootstrap"

   | objClass |
   objClass := self objClassStructure.
   self defineAllocateMethodIn: objClass.
   self defineNewMethodIn: objClass.
   self defineInitializeMethodIn: objClass.
   objClass
     addUnaryMethod: #isMetaclass
     withBody: 'objself objIVs includes: #superclass'.
  "an object is a class if is class is a metaclass. cool"

   objClass
     addUnaryMethod: #isClass
     withBody: 'objself objClass send: #isMetaclass withArguments:#()'.

   ^ objClass
]]]

Pour que la méthode ==createObjClass== fonctionne, nous devons implémenter la méthode qu'elle appelle. Implémenter alors

- la primitive ==objClassStructure== qui crée la classe ==ObjClass== en invoquant le message ==new== à la classe ==ObjClass==. Notez qu'au cours de cette méthode le symbole ==ObjClass== fait référence à deux entités différentes car la nouvelle classe qui est créée en utilisant l'ancienne est déclarée dans le dictionnaire des classes avec le même nom.


!!!! Votre travail.
Assurez-vous d'avoir lu et exécuté la méthode de test : ==testCreateObjClassStructure==.
Implémentez maintenant la primitive ==createObjClass== qui commence comme suit :

[[[
Obj class >> createObjClass

   | objClass |
   objClass := self objClassStructure.
   self defineAllocateMethodIn: objClass.
   self defineNewMethodIn: objClass.
   self defineInitializeMethodIn: objClass.
   ...
   ^ objClass
]]]

Définissez également les méthodes suivantes :
- la méthode objMethod ==isClass== qui renvoie true.
- la méthode objMethod ==isMetaclass== qui renvoie true.

[[[
objClass
   addUnaryMethod: #isMetaclass
   withBody: 'objself objIVs includes: #superclass'.

   "an object is a class if is class is a metaclass. cool"
]]]

[[[
objClass
  addUnaryMethod: #isClass
  withBody: 'objself objClass send: #isMetaclass withArguments:#()'.
]]]


- la primitive ==defineInitializeMethodIn : anObjClass== qui ajoute l'objMethod ==initialize== à l'objClass passée en argument. L'objMethod ==initialize== prend le receveur (une objClass) et une liste d'initargs et initialise le receveur selon les spécifications données par la liste d'initargs. En particulier, il doit être initialisé comme n'importe quel autre objet, puis il doit calculer sa variable d'instance (c'est-à-dire que les variables d'instance héritées sont calculées), les mots-clés sont également calculés, le dictionnaire de méthodes doit être défini et la classe est ensuite déclarée comme une classe existante. Nous vous fournissons le modèle suivant pour vous aider.

[[[
Obj class>>defineInitializeMethodIn: objClass

   objClass
     addMethod: #initialize
     args: 'initArray'
     withBody:
        'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.
         objself objIVs: (objself
                  computeNewIVFrom:
                        (Obj giveClassNamed: objself objSuperclassId) objIVs
                  with: objself objIVs).
        objself computeAndSetKeywords.
        objself objMethodDict: IdentityDictionary new.
        Obj declareClass: objself.
        objself'
]]]


[[[
Obj class >> defineInitializeMethodIn: objClass

  objClass
     addMethod: #initialize
     args: 'initArray'
     withBody:
         'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.
         objself objIVs: (objself
           computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs
           with: objself objIVs).
         objself computeAndSetKeywords.
         objself objMethodDict: IdentityDictionary new.
         Obj declareClass: objself.
         objself'
]]]

!!!! Votre travail.
Assurez-vous que vous exécutez la méthode de test : ==testCreateObjClassMessage==.

Notez les points suivants :
- Les variables d'instance spécifiées localement ne sont plus que les variables d'instance qui décrivent une classe. La variable d'instance ==class== est héritée de ==ObjObject==.
- La méthode ==initialize== effectue maintenant un super envoi pour invoquer l'initialisation effectuée par ==ObjObject==.


!!!Premières classes d'utilisateurs : ObjPoint
Maintenant que ObjVLisp est créé, nous pouvons commencer à programmer quelques classes.
Implémentez la classe ==ObjPoint== et ==ObjColoredPoint==. Voici une implémentation possible.

Vous pouvez choisir de l'implémenter au niveau de la classe Obj ou mieux encore dans une classe nommée ==ObjPointTest==.

Veillez à ce que votre scénario couvre les aspects suivants :
- Créez tout d'abord la classe ==ObjPoint==.
- Créez une instance de la classe ==ObjPoint==.
- Envoyez à cette instance certains messages définis dans ==ObjObject==.

Définissez la classe ==ObjPoint== afin de pouvoir créer des points comme ci-dessous (créez une méthode Pharo pour la définir).

[[[
ObjClass send: #new
   withArguments: #((#name: #ObjPoint #iv: #(#x y) #superclass: #ObjObject)).
]]]

[[[
aPoint := pointClass send: #new withArguments: #((#x: 24 #y: 6)).
aPoint send: #getIV withArguments: #(#x).
aPoint send: #setIV withArguments: #(#x 25).
aPoint send: #getIV withArguments: #(#x).
]]]

Ajoutez ensuite quelques fonctionnalités à la classe ==ObjPoint== comme les méthodes ==x==, ==x:==, ==display== qui impriment le receveur.

[[[
Obj ObjPoint
   addUnaryMethod: #givex
   withBody: 'objself valueOfInstanceVariable: #x '.
Obj ObjPoint
   addUnaryMethod: #display
   withBody:
    'Transcript cr;
      show: ''aPoint with x = ''.
    Transcript show: (objself send: #givex withArguments: #()) printString;
   cr'.
]]]

Puis testez ces nouvelles fonctionnalités.

[[[
aPoint send: #x withArguments: #().
aPoint send: #x: withArguments: #(33).
aPoint send: #display withArguments: #().
]]]


!!! Premières classes d'utilisateurs : ObjColoredPoint
En suivant la même idée, définissez la classe ==ObjColored==.

Créez une instance et envoyez-lui quelques messages de base.

[[[
aColoredPoint := coloredPointClass
   send: #new
   withArguments: #((#x: 24 #y: 6 #color: #blue)).
]]]

[[[
aColoredPoint send: #getIV withArguments: #(#x).
aColoredPoint send: #setIV withArguments: #(#x 25).
aColoredPoint send: #getIV withArguments: #(#x).
aColoredPoint send: #getIV withArguments: #(#color).
]]]

!!!! Votre travail.
Définissez quelques fonctionnalités et invoquez-les : la méthode color, implémentez la méthode display de façon à ce qu'elle invoque la superclasse et ajoute quelques informations relatives à la couleur. Voici un exemple :

[[[
coloredPointClass addUnaryMethod: #display
   withBody:
     'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.
      Transcript cr;
         show: '' with Color = ''.
      Transcript show: (objself send: #giveColor withArguments: #()) printString; cr'.
]]]

[[[
aColoredPoint send: #x withArguments: #().
aColoredPoint send: #color withArguments: #().
aColoredPoint send: #display withArguments: #()
]]]




!!! Une métaclasse pour les premiers utilisateurs : ObjAbstract
Implémentez maintenant la métaclasse ==ObjAbstract== qui définit les instances (classes) qui sont abstraites c'est-à-dire qui
ne peuvent pas créer d'instances. Cette classe devrait lever une erreur lorsqu'elle exécute le message ==new==.

L'exemple suivant vous montre une utilisation possible de cette métaclasse.
[[[
ObjAbstractClass
  send: #new
  withArguments: #(#(#name: #ObjAbstractPoint
            #iv: #()
            #superclass: #ObjPoint)).

ObjAbstractPoint send: #new
   withArguments: #(#(#x: 24 #y: 6))        "should raise an error"
]]]

Vous devez redéfinir la méthode ==new==. Notez que la ==ObjAbstractClass== est une instance de ==ObjClass== parce que c'est une classe et en hérite parce que c'est une métaclasse.


!!!Nouvelles fonctionnalités que vous pouvez implémenter

Vous pouvez implémenter quelques fonctionnalités simples :
- définir une métaclasse qui définit automatiquement des accesseurs pour les variables des instances spécifiées.
- éviter que l'on puisse changer le sélecteur et les arguments lors de l'appel d'un super envoi.

!!!! Variables partagées
Notez que contrairement à la proposition faite dans le 6ème postulat du modèle original d'ObjVLisp, les variables d'instance de classe ne sont pas équivalentes aux variables partagées.  Selon le 6ème postulat, une variable partagée sera stockée dans l'instance représentant la classe et non dans une variable d'instance de la classe représentant les variables partagées.  Par exemple si une station de travail a une variable partagée nommée ==domaine==. Mais domaine ne devrait pas être une variable d'instance supplémentaire de la classe de ==station de travail==. En effet, domaine n'a rien à voir avec la description de la classe.

La solution correcte est que ==domain== est une valeur maintenue dans la liste de la variable partagée de la classe ==Workstation==. Cela signifie que
une ''classe'' possède une information supplémentaire pour la décrire : une variable d'instance ==sharedVariable== contenant des paires.  Nous devrions donc être en mesure d'écrire

[[[
Obj Workstation getIV: #sharedVariable
or
Obj Workstation sharedVariableValue: #domain

and get
 #((domain 'inria.fr'))
]]]

Introduire les variables partagées : ajouter une nouvelle variable d'instance dans la classe ==ObjClass==.
classe ==ObjClass== pour contenir un dictionnaire de liaisons de variables partagées (un
symbole et une valeur) qui peut être interrogé à l'aide de méthodes spécifiques :
==sharedVariableValue:==, ==sharedVariableValue:put:==.
